r"""
Linear family of coordinates on a veering triangulation
"""

from .env import sage, ppl
from .constants import VERTICAL, HORIZONTAL
from .permutation import perm_cycle_string


from .veering_triangulation import VeeringTriangulation

if sage is not None:
    from sage.structure.element import get_coercion_model
    from sage.matrix.constructor import matrix
    from sage.geometry.polyhedron.constructor import Polyhedron

    cm = get_coercion_model()
else:
    matrix = None
    Polyhedron = None

    cm = None


def subspace_are_equal(subspace1, subspace2, check=True):
    r"""
    Test whether the subspaces generated by the rows of ``subspace1`` and
    ``subspace2`` are equal.

    INPUT:

    - ``subspace1``, ``subspace2`` -- full rank matrices with the same number
      of columns

    - ``check`` -- boolean (default ``True``)

    EXAMPLES::

        sage: from veerer.linear_family import subspace_are_equal

        sage: m1 = random_matrix(ZZ, 3, 5)
        sage: m2 = copy(m1)
        sage: m2.add_multiple_of_row(0, 1, -2)
        sage: m2.add_multiple_of_row(0, 2, 1)
        sage: m2.add_multiple_of_row(1, 2, 1)
        sage: subspace_are_equal(m1, m2)
        True

        sage: m1 = matrix(ZZ, [[1, 1, 0]])
        sage: m2 = matrix(ZZ, [[1, 1, -1]])
        sage: subspace_are_equal(m1, m2)
        False
    """
    if check:
        if subspace1.ncols() != subspace2.ncols():
            raise ValueError('subspace1 and subspace2 of different ambient dimensions')
        if subspace1.rank() != subspace1.nrows():
            raise ValueError('subspace1 not full rank')
        if subspace2.rank() != subspace2.nrows():
            raise ValueErrror('subspace2 not full rank')

    n = subspace1.nrows()
    if n != subspace2.nrows():
        return False

    base_ring = cm.common_parent(subspace1.base_ring(), subspace2.base_ring())
    mat = matrix(base_ring, n + 1, subspace1.ncols())
    mat[:n] = subspace1
    for v in subspace2.rows():
        mat[n] = v
        r = mat.rank()
        if r < n:
            raise RuntimeError('matrices where expected to be full rank')
        if r > n:
            return False
    return True


class VeeringTriangulationLinearFamily(VeeringTriangulation):
    r"""
    Veering triangulation together with a subspace of H^1(S, Sigma; \bR) that
    describes a (piece of a) linear GL(2,R)-invariant immersed sub-orbifold.
    """
    __slots__ = ['_subspace']

    def __init__(self, *args, check=True):
        if len(args) == 2:
            vt, subspace = args
            t = vt
            colouring = vt._colouring
        elif len(args) == 3:
            t, colouring, subspace = args
        VeeringTriangulation.__init__(self, t, colouring, check=False)

        if not isinstance(subspace, sage.structure.element.Matrix):
            subspace = matrix(subspace)

        self._subspace = subspace
        if check:
            self._check(ValueError)

    def base_ring(self):
        return self._subspace.base_ring()

    def __str__(self):
        r"""
        Return a string representation.

        TESTS::

            sage: from veerer import *
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", [RED, RED, BLUE])
            sage: str(vt.as_linear_family())
            'VeeringTriangulationLinearFamily("(0,1,2)(~2,~0,~1)", "RRB", [(1, 1, 0), (1, 0, -1)])'
        """
        return "VeeringTriangulationLinearFamily(\"{}\", \"{}\", {})".format(
               perm_cycle_string(self._fp, False, self._n, self._ep),
               self._colouring_string(short=True),
               self._subspace.rows())

    def __repr__(self):
        return str(self)

    def _check(self, error=ValueError):
        subspace = self._subspace
        VeeringTriangulation._check(self, error)
        if subspace.ncols() != self.num_edges():
            raise error('subspace matrix has wrong dimension')
        if subspace.rank() != subspace.nrows():
            raise error('subspace matrix is not of full rank')
        # test that elements satisfy the switch condition
        for v in subspace.rows():
            self._set_switch_conditions(self._tt_check, v, VERTICAL)

    def __eq__(self, other):
        if type(self) is not type(other):
            raise TypeError
        test = (VeeringTriangulation.__eq__(self, other) and
                self._subspace.nrows() != other._subspace.nrows())
        if not test:
            return False

        return subspace_are_equal(self._subspace, other._subspace)

    def __ne__(self, other):
        if type(self) is not type(other):
            raise TypeError
        test = (VeeringTriangulation.__eq__(self, other) and
                self._subspace.nrows() != other._subspace.nrows())
        if not test:
            return True

        return not subspace_are_equal(self._subspace, other._subspace)

    def train_track_polytope(self, slope=VERTICAL, low_bound=0):
        r"""
        Return the polytope of non-negative elements in the subspace.
        """
        if slope == HORIZONTAL:
            raise NotImplementedError

        base_ring = self.base_ring()
        m = self.num_edges()
        pos = Polyhedron(base_ring=base_ring, ieqs=[(0,) * i + (1,) + (0,) * (m - i) for i in range(1, m + 1)])
        subspace = Polyhedron(base_ring=base_ring, lines=self._subspace.rows())
        return subspace.intersection(pos)

    def dimension(self):
        r"""
        Return the dimension of the linear family.
        """
        return self._subspace.nrows()

    def is_core(self, method='polytope'):
        r"""
        Test whether this linear family is core.

        It is core, if the dimension of the polytope given by the train-track
        and non-negativity conditions is full dimensional in the subspace.

        EXAMPLES::

            sage: from veerer import *
            sage: vt = VeeringTriangulation("(0,1,2)(~0,~1,~2)", [RED, RED, BLUE])
            sage: vt.as_linear_family().is_core()
            True
            sage: VeeringTriangulationLinearFamily(vt, [1, 0, -1]).is_core()
            False
        """
        if method == 'polytope':
            return self.train_track_polytope().dimension() == self._subspace.nrows()
        else:
            raise NotImplementedError

    def relabel(self, p):
        pass

    def iso_sig(self):
        pass

    # TODO: change to canonicalize ? Since we also need to canonicalize the subspace
    # it is not only about labels
    def set_canonical_labels(self):
        pass

    def is_isomorphic_to(self, other, certificate=False):
        pass

    def flip(self, e, col, check=True):
        pass

    def geometric_polytope(self, x_low_bound=0, y_low_bound=0, hw_bound=0):
        pass

    def geometric_flips(self):
        pass


class VeeringTriangulationLinearFamilies:
    r"""
    A collection of linear families.
    """
    @staticmethod
    def L_shaped_surface(a1, a2, b1, b2, t1=0, t2=0):
        vt, s, t = VeeringTriangulations.L_shaped_surface(a1, a2, b1, b2, t1, t2)
        return VeeringTriangulationLinearFamily(vt, matrix([s, t]))
